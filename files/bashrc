#!/bin/bash
################################################################################
# !!! WARNING !!!
################################################################################
# DO NOT EDIT THIS FILE
# PLACE ALL SYSTEM SPECIFIC ALIAS/PATHS/LICENSE_EXPORTS/ETC INTO
# ~/.bash_aliases
################################################################################

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# source global definitions
[ -f /etc/bashrc ] && source /etc/bashrc

# change color when running as su
if [ "`id -u`" -eq 0 ]; then
    PS1="[ \[\e[1;31m\]λ\[\e[1;32m\]\[\e[49m\]:\h \W \[\e[0m\]] "
else
    PS1="[ \[\e[1;32m\]λ:\h \W \[\e[0m\]] "
fi

# adding /bin causes issues with buildroot
def_path=/usr/bin:/usr/sbin:/usr/local/bin:$HOME/.local/bin:/var/lib/snapd/snap/bin
PATH=$def_path

# add python 2.7 path ... needed for ranger
export PYTHONPATH=/usr/local/lib/python2.7/site-packages

# don't put duplicate lines in the history. See bash(1) for more options
export HISTCONTROL=ignoredups:erasedups
export HISTTIMEFORMAT="%Y/%m/%d %H:%M:%S:   "

# Causes bash to append to history instead of overwriting it so if you start a new terminal, you have old session history
shopt -s histappend
PROMPT_COMMAND='history -a'

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# Color for manpages
# explicitly state manpath, seemed to be missing in centos
export MANPATH=$MANPATH:/usr/share/man
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'

# duh
export EDITOR='vim'

# aliases
alias vi='vim'
alias kviv='kill $(pidof vivado)'
alias ksdk='kill $(pidof xsdk)'
alias pdf='xpdf'
alias xclip='xclip -selection c' # cat some.file | xclip # now it is in system clipboard
alias scpi='scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null' # ignore keys
alias sshi='ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null' # ignore keys
alias rst2html='rst2html --stylesheet-dirs=~/.rst2html/html --stylesheet=sm-docutils.css'
alias rst2pdf='rst2pdf --stylesheet-path=~/.rst2pdf --stylesheets=rst2pdf.style --use-floating-images'
alias rst2latex='python ~/.rst2latex.py'
alias mkdir='mkdir -pv'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias llusb='ls /dev/ttyUSB*'
alias r='ranger --choosedir=$HOME/.rangerdir; LASTDIR=`cat $HOME/.rangerdir`; cd "$LASTDIR"' # when ranger closes terminal will cd to directory it was at
alias files='find -type f -exec du -Sh {} + | sort -rh | head -n 10' # sort files by size in local dir
alias vimb='vim ~/.bashrc'
alias vimba='vim ~/.bash_aliases'
alias vimv='vim ~/.vimrc'
alias vimi='vim ~/.config/i3/config'
alias excel='sc-im'

# Adding color
alias ls='ls -hN --color=auto --group-directories-first'
alias l='ls -hN --color=auto --group-directories-first'
alias ll='ls -lahN --color=auto --group-directories-first'

# arch aliases
alias pac='sudo pacman -Sy --noconfirm --needed'
alias pacup='sudo pacman -Syu --noconfirm --needed'
alias aur='makepkg -si --skippgpcheck --noconfirm --needed'

# create quick rst readmes from template
readme () {
    name=$1
    len=${#name}
    sep=$(printf '=%.0s' $(seq $len))
    fname="${name// /-}"
    cp ~/.readmeTemplate.rst $(pwd)/${fname}.rst
    sed -i 's/Title/'"$name"'/g' $(pwd)/${fname}.rst
    sed -i 's/xxx/'$sep'/g' $(pwd)/${fname}.rst
}

# smart extract
extract () {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1;;
            *.tar.gz)    tar xzf $1;;
            *.tar.xz)    tar tvf $1;;
            *.bz2)       bunzip2 $1;;
            *.rar)       rar x $1;;
            *.gz)        gunzip $1;;
            *.tar)       tar xf $1;;
            *.tbz2)      tar xjf $1;;
            *.tgz)       tar xzf $1;;
            *.zip)       unzip $1;;
            *.Z)         uncompress $1;;
            *.7z)        7z x $1;;
            *)           echo "'$1' cannot be extracted via extract()";;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# ReMove all files containing a grep Pattern
rmp () {
    pat=$1
    a=$(grep -lrI $1 .)
    slen=${#a}
    if [ $slen -ne 0 ]; then
        echo -e "... rm -f the following files containing the string : \"$1\" ?\n"
        echo $a | tr " " "\n\t"
        echo ""
        read -rp "... [y/n] : " response
        case "$response" in
            [yY][eE][sS]|[yY])
                grep -lrIZ $1 . | xargs -0 rm -f --
                echo "... Removed"
                ;;
            *)
                echo "... Not Removed"
                ;;
        esac
    else
        echo "String \"$1\" not found in directory using 'grep -lrI' ... skipping"
    fi
}

# publicip - shows public IP address
publicip ()
{
    echo "--------------- Public IP ---------------"
    myip=`lynx -dump -hiddenlinks=ignore -nolist http://checkip.dyndns.org:8245/ | sed '/^$/d; s/^[ ]*//g; s/[ ]*$//g' `
    echo "${myip}"
    echo "-----------------------------------------"
}

# dirsize - finds directory sizes and lists them for the current directory
dirsize ()
{
    nfiles=$(find . -type f | wc -l)
    s=$(du -sh . | awk '{print $1}')
    du -shx * .[a-zA-Z0-9_]* 2> /dev/null | \
    egrep '^ *[0-9.]*[MG]' | sort -n > /tmp/list
    egrep '^ *[0-9.]*M' /tmp/list
    egrep '^ *[0-9.]*G' /tmp/list
    rm -rf /tmp/list
    echo "Total number of recursive files : $nfiles ($s)"
}

# source files
[[ -r /usr/local/etc/profile.d/bash_completion.sh ]] && . /usr/local/etc/profile.d/bash_completion.sh
[ -f ~/.fzf.bash ] && source ~/.fzf.bash
# all system indepedent aliases, path modifications, etc should be in ~/.bash_aliases
[ -f ~/.bash_aliases ] && source ~/.bash_aliases
[ -f ~/.config/watson/watson.completion.txt ] && source ~/.config/watson/watson.completion.txt

if [ -d $HOME/.rbenv ]; then
    export PATH="$HOME/.rbenv/bin:$PATH"
    eval "$(rbenv init -)"
fi

# remove duplicate entries in path
if [ -n "$PATH" ]; then
    old_PATH=$PATH:; PATH=
    while [ -n "$old_PATH" ]; do
        x=${old_PATH%%:*}       # the first remaining entry
        case $PATH: in
            *:"$x":*) ;;          # already there
            *) PATH=$PATH:$x;;    # not there yet
        esac
        old_PATH=${old_PATH#*:}
    done
    PATH=${PATH#:}
    unset old_PATH x
fi
