#!/bin/bash
################################################################################
# !!! WARNING !!!
################################################################################
# DO NOT EDIT THIS FILE
# PLACE ALL SYSTEM SPECIFIC ALIAS/PATHS/LICENSE_EXPORTS/ETC INTO
# ~/.bash_aliases
################################################################################

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# source global definitions
[ -f /etc/bashrc ] && source /etc/bashrc

# change color when running as su
if [ "`id -u`" -eq 0 ]; then
    PS1="[ \[\e[1;31m\]λ\[\e[1;32m\]\[\e[49m\]:\h \W \[\e[0m\]] "
else
    PS1="[ \[\e[1;32m\]λ:\h \W \[\e[0m\]] "
fi

# adding /bin causes issues with buildroot
def_path=/usr/bin:/usr/sbin:/usr/local/bin:$HOME/.local/bin:/var/lib/snapd/snap/bin
PATH=$def_path

# add python 2.7 path ... needed for ranger
export PYTHONPATH=/usr/local/lib/python2.7/site-packages

# don't put duplicate lines in the history. See bash(1) for more options
export HISTCONTROL=ignoredups:erasedups
export HISTTIMEFORMAT="%Y/%m/%d %H:%M:%S:   "

# Causes bash to append to history instead of overwriting it so if you start a new terminal, you have old session history
shopt -s histappend
PROMPT_COMMAND='history -a'

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# Color for manpages
# explicitly state manpath, seemed to be missing in centos
export MANPATH=$MANPATH:/usr/share/man
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'

# duh
export EDITOR='vim'
export VISUAL='vim'
export CSCOPE_EDITOR='vim'

# aliases
alias invert='xcalib -invert -alter'
alias vi='vim'
alias xclip='xclip -selection c' # cat some.file | xclip # now it is in system clipboard
alias scpi='scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null' # ignore keys
alias sshi='ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null' # ignore keys
alias rst2html='rst2html --stylesheet-dirs=~/.rst2html/html --stylesheet=sm-docutils.css'
alias mkdir='mkdir -pv'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias llusb='ls /dev/ttyUSB*'
alias r='ranger --choosedir=$HOME/.rangerdir; LASTDIR=`cat $HOME/.rangerdir`; cd "$LASTDIR"' # when ranger closes terminal will cd to directory it was at
alias files='find -type f -exec du -Sh {} + | sort -rh | head -n 10' # sort files by size in local dir
alias vimb='vim ~/.bashrc'
alias vimba='vim ~/.bash_aliases'
alias vimv='vim ~/.vimrc'
alias vimi='vim ~/.config/i3/config'
alias vimx='vim ~/.bash_vivado'
alias lynx='lynx -cfg=~/.config/lynx/lynx.cfg'
alias grepy='grep -r --color=auto --line-number'
alias asciibanner="figlet"

# Adding color
alias ls='ls -hN --color=auto --group-directories-first'
alias l='ls -hN --color=auto --group-directories-first'
alias ll='ls -lahN --color=auto --group-directories-first'

# arch aliases
alias pac='sudo pacman -Sy --noconfirm archlinux-keyring && sudo pacman -Sy --noconfirm --needed'
alias pacup='sudo pacman -Sy --noconfirm archlinux-keyring && sudo pacman -Syu --noconfirm --needed && sudo pacman -Sc --noconfirm'
alias aur='makepkg -si --skippgpcheck --noconfirm --needed'

# create quick rst readmes from template
readme ()
{
    name=$1
    len=${#name}
    sep=$(printf '=%.0s' $(seq $len))
    fname="${name// /-}"
    cp ~/.readmeTemplate.rst $(pwd)/${fname}.rst
    sed -i 's/Title/'"$name"'/g' $(pwd)/${fname}.rst
    sed -i 's/xxx/'$sep'/g' $(pwd)/${fname}.rst
}

# smart extract
extract ()
{
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1;;
        *.tar.gz)    tar xzf $1;;
    *.tar.xz)    tar tvf $1;;
*.bz2)       bunzip2 $1;;
            *.rar)       rar x $1;;
        *.gz)        gunzip $1;;
    *.tar)       tar xf $1;;
*.tbz2)      tar xjf $1;;
            *.tgz)       tar xzf $1;;
        *.zip)       unzip $1;;
    *.Z)         uncompress $1;;
*.7z)        7z x $1;;
            *)           echo "'$1' cannot be extracted via extract()";;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# ReMove all files containing a grep Pattern
rmp ()
{
    pat=$1
    a=$(grep -lrI $1 .)
    slen=${#a}
    if [ $slen -ne 0 ]; then
        echo -e "... rm -f the following files containing the string : \"$1\" ?\n"
        echo $a | tr " " "\n\t"
        echo ""
        read -rp "... [y/n] : " response
        case "$response" in
            [yY][eE][sS]|[yY])
                grep -lrIZ $1 . | xargs -0 rm -f --
                echo "... Removed"
                ;;
            *)
                echo "... Not Removed"
                ;;
        esac
    else
        echo "String \"$1\" not found in directory using 'grep -lrI' ... skipping"
    fi
}

# publicip - shows public IP address
publicip ()
{
    echo "--------------- Public IP ---------------"
    myip=`lynx -dump -hiddenlinks=ignore -nolist http://checkip.dyndns.org:8245/ | sed '/^$/d; s/^[ ]*//g; s/[ ]*$//g' `
    echo "${myip}"
    echo "-----------------------------------------"
}

# dirsize - finds directory sizes and lists them for the current directory
dirsize ()
{
    nfiles=$(find . -type f | wc -l)
    s=$(du -sh . | awk '{print $1}')
    du -shx * .[a-zA-Z0-9_]* 2> /dev/null | \
        grep -E '^ *[0-9.]*[MG]' | sort -n > /tmp/list
    grep -E '^ *[0-9.]*M' /tmp/list
    grep -E '^ *[0-9.]*G' /tmp/list
    rm -rf /tmp/list
    echo "Total number of recursive files : $nfiles ($s)"
}

# autocomplete make commands
complete -W "\`grep -oE '^[a-zA-Z0-9_.-]+\s*:([^=]|$)' ?akefile | sed 's/[^a-zA-Z0-9_.-]*$//'\`" make

################################################################################
# START SVN SHIT
################################################################################

# create a stash functionality in svn
export STASHDIR=~/.svnstash
svnstash () {
    # Help screen
    if [ -z $1 ] || [[ $1 =~ ^(-?-?[Hh](elp)?(ELP)?)$ ]]; then
        echo "svnstash replicates 'git stash' for a svn repo."
        echo " usage: 'svnstash [save]  <stash_name>' stashes changes [overwriting old stash if same name] and reverts the directory."
        echo "    or: 'svnstash keep    <stash_name>' creates stash, but does not revert the directory"
        echo "    or: 'svnstash list'                 lists names of stashed changes."
        echo "    or: 'svnstash pop     <stash_name>' applies changes and removes stash"
        echo "    or: 'svnstash apply   <stash_name>' applies changes and keeps stash"
        echo "    or: 'svnstash peek    <stash_name>' displays the stashed changes"
        echo "    or: 'svnstash discard <stash_name>' throws away stash without applying changes"
        echo "    or: 'svnstash drop    <stash_name>' same as 'discard'"
        return
    fi

    # Create file path for new stash file
    local dir=$STASHDIR
    [[ ! -d $STASHDIR ]] && mkdir $STASHDIR
    if [ -z $2 ] && ([ $1 == "apply" ] || [ $1 == "pop" ]  || [ $1 == "peek" ] || [ $1 == "save" ] ||
        [ $1 == "keep" ]  || [ $1 == "drop" ] || [ $1 == "discard" ]); then
    echo "$1 expects a <stash_name>"; return
    elif [ -z $2 ]; then local file="${dir}/${1}.stash";
    else                 local file="${dir}/${2}.stash"; fi

    # Double check if it exists / doesn't exist.
    if ([ $1 == "keep" ] || [ $1 == "save" ] || [ -z $2 ]) && [ -f $file ]; then
        echo "stash with name '$(basename -s.stash $file)' exists already!"; return
    elif [ ! -f $file ] && ([ $1 == "apply" ] || [ $1 == "pop" ]); then
        echo "stash with name '$(basename -s.stash $file)' doesn't exist!"; return; fi

        # Apply desired changes.
    case $1 in
            "drop")    rm $file;;
            "discard") rm $file;;
            "apply")   patch -p0 < $file;;
            "pop")     patch -p0 < $file; rm $file;;
            "list")    ls -1t $dir | sed 's_\.\w*__g';;
            "peek")    colordiff < $file | less -r;;
            "keep")    svn diff > $file;;
            "save")    svn diff > $file; svn revert -R .;;
            *)         svn diff > $file; svn revert -R .;;
    esac
}
# autocomplete svnstash
complete -W "-f help save keep list pop apply peek drop discard \`[ -d $STASHDIR ] && ls $STASHDIR | sed 's/.stash$//'\`" svnstash

# add color to svn diff
svndiff () {
    svn diff -x "-w --ignore-eol-style" "${@}" | colordiff
}

# add color to svn
alias svns="python ~/.subversion/svn-color.py status"

################################################################################
# END SVN SHIT
################################################################################

# source files
[[ -r /usr/local/etc/profile.d/bash_completion.sh ]] && . /usr/local/etc/profile.d/bash_completion.sh
[ -f ~/.fzf.bash ] && source ~/.fzf.bash
# all system indepedent aliases, path modifications, etc should be in ~/.bash_aliases
[ -f ~/.bash_aliases ] && source ~/.bash_aliases
[ -f ~/.bash_vivado ] && source ~/.bash_vivado
[ -f ~/.bash_svn ] && source ~/.bash_svn
[ -f ~/.config/watson/watson.completion.txt ] && source ~/.config/watson/watson.completion.txt

if [ -d $HOME/.rbenv ]; then
    export PATH="$HOME/.rbenv/bin:$PATH"
    eval "$(rbenv init -)"
fi

# remove duplicate entries in path
if [ -n "$PATH" ]; then
    old_PATH=$PATH:; PATH=
    while [ -n "$old_PATH" ]; do
        x=${old_PATH%%:*}       # the first remaining entry
        case $PATH: in
            *:"$x":*) ;;          # already there
        *) PATH=$PATH:$x;;    # not there yet
    esac
    old_PATH=${old_PATH#*:}
done
PATH=${PATH#:}
unset old_PATH x
fi
